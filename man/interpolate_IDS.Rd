% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolation.R
\name{interpolate_IDS}
\alias{interpolate_IDS}
\title{Inverse distance squared interpolation}
\usage{
interpolate_IDS(precip_df, out_xy, elev_gradient = 0)
}
\arguments{
\item{precip_df}{Must contain precip, x, y columns (elev optional)}

\item{out_xy}{Coordinates (x, y) at which to interpolate (elev optional)}

\item{elev_gradient}{Linear elevation gradient (see details)}
}
\description{
Inverse distance squared interpolation
}
\details{
For elevation gradient, \code{elev_gradient} should be specified in units
of precipitation over elevation (i.e., if precipitation is in mm and
elevation in m, \code{elev_gradient} should be [mm/m]). Additionally,
\code{precip_df} and \code{out_xy} must contain a column named \code{elev}.
}
\examples{
# Generate topography with sin functions
get_elev <- function(x, y) 500*sin(x / 750) + 500*sin(y / 1000) + 1000

# Generate random precipitation observations
set.seed(100)
N_obs<- 10
precip_df <- data.frame(precip = rnorm(N_obs, 750, 100),
                        x = runif(N_obs, 0, 5000),
                        y = runif(N_obs, 0, 5000))
precip_df$elev <- get_elev(precip_df$x, precip_df$y)

out_xy <- expand.grid(x = seq(0, 5000, length.out = 9),
                      y = seq(0, 5000, length.out = 9))
out_xy$elev <- get_elev(out_xy$x, out_xy$y)

# Plot elevation
library(ggplot2)
ggplot() +
  geom_raster(data = out_xy, aes(x, y, fill = elev)) + coord_equal()

# Interpolate precipitation
out_xy$precip_interp1 <- interpolate_IDS(precip_df, out_xy, elev_gradient = 0)
out_xy$precip_interp2 <- interpolate_IDS(precip_df, out_xy, elev_gradient = 0.1)

# Plot the data
ggplot() +
  geom_raster(data = out_xy, aes(x, y, fill = precip_interp2)) +
  geom_point(data = precip_df, aes(x, y, fill = precip), shape = 21, size = 3) +
  scale_fill_viridis_c() +
  coord_equal()
}
